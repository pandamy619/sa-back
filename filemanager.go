package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
)

type Resp struct {
	Message     string `json:"message"`
	Description string `json:"description"`
	Code        int    `json:"code"`
}

func uploadHandler(w http.ResponseWriter, r *http.Request) {
	// Parse our multipart form, 10 << 20 specifies a maximum
	// upload of 10 MB files.
	if err := r.ParseMultipartForm(10 << 20); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
	file, handler, err := r.FormFile("file")

	if err != nil {
		NewError(w, "Error Retrieving the File", 400)
		return
	}
	defer file.Close()

	fileExt := filepath.Ext(handler.Filename)
	if fileExt != ".xlsx" && fileExt != ".csv" {
		NewError(w, "Invalid file format", 415)
	}

	_, err = GetFileContentType(file)
	if err != nil {
		NewError(w, err.Error(), 400)
		return
	}

	path, err := tempDir("./tmp/", "")
	if err != nil {
		NewError(w, err.Error(), 400)
		return
	}
	tmpFile, err := tempFile(path, "upload-*.xlsx")
	if err != nil {
		NewError(w, err.Error(), 400)
		return
	}
	defer tmpFile.Close()

	fileBytes, err := readAll(file)
	if err != nil {
		NewError(w, err.Error(), 400)
		return
	}
	b, err := tmpFile.Write(fileBytes)
	if err != nil {
		NewError(w, err.Error(), 400)
		return
	}
	resp, err := json.Marshal(
		Resp{
			Message:     "File uploaded successfully",
			Description: fmt.Sprintf("Wrote %d bytes", b),
			Code:        200,
		})
	if err != nil {
		NewError(w, err.Error(), http.StatusInternalServerError)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write(resp)
}

// TempDir creates a new temporary directory in the directory dir.
// The directory name is generated by taking pattern and applying a random string to the end.
func tempDir(dir string, pattern string) (string, error) {
	path, err := ioutil.TempDir(dir, pattern)
	if err != nil {
		return "", err
	}
	return path, nil
}

// TempFile creates a new temporary file in the directory dir,
// opens the file for reading and writing, and returns the resulting *os.File.
func tempFile(path string, pattern string) (*os.File, error) {
	file, err := ioutil.TempFile(path, pattern)
	if err != nil {
		return nil, err
	}
	return file, nil
}

// ReadAll reads from r until an error or EOF and returns the data it read.
func readAll(file multipart.File) ([]byte, error) {
	fileBytes, err := ioutil.ReadAll(file)
	if err != nil {
		return nil, err
	}
	return fileBytes, nil
}

func GetFileContentType(file multipart.File) (string, error) {
	buffer := make([]byte, 512)
	_, err := file.Read(buffer)
	if err != nil {
		return "", err
	}
	contentType := http.DetectContentType(buffer)
	return contentType, nil
}
